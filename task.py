
import sys

# can implement using a class with the below functions as methods


# ./task help
def taskhelp():
    sys.stdout.buffer.write("Usage :-\n".encode('utf8'))

    usages = {
        '$ ./task add 2 hello world': '# Add a new item with priority 2 and text "hello world" to the list',
        '$ ./task ls': '# Show incomplete priority list items sorted by priority in ascending order',
        '$ ./task del INDEX': '# Delete the incomplete item with the given index',
        '$ ./task done INDEX': '# Mark the incomplete item with the given index as complete',
        '$ ./task help': '# Show usage',
        '$ ./task report': '# Statistics',
    }

    # refer to readme file to get the count of the padding before description of commands
    # got the count relative to the first command
    total_left_gap = len(list(usages.keys())[0])+4

    for command, description in usages.items():
        padding_len = total_left_gap-len(command)
        padding = padding_len*" "
        command_description = command+padding+description+"\n"
        sys.stdout.buffer.write(command_description.encode('utf8'))



# ./task add
def add(arguments):
    # check for validity of arguments
    invalid = False
    if arguments is None:
        invalid = True
    elif len(arguments) < 2:
        invalid = True
    try:
        arguments[0] = int(arguments[0])
    except:
        invalid = True

    if invalid:
        print("Error: Missing tasks string. Nothing added!")
        return

    add_task_prioritynum = arguments[0]
    add_task = arguments[1]
    task_string = str(arguments[0])+" "+arguments[1]

    try:
        task_file_handle = open('task.txt', 'r')
    except:
        task_file_handle = open('task.txt', 'w+')

    tasks = task_file_handle.read().split('\n')[:-1]
    # sliced tasks to eliminate line generated by \n in the end of the file

    # to store contents that have to be written to the task file
    tasks_list = []
    added = False

    for task in tasks:
        task = task.split(' ')
        prioritynum = int(task[0])
        # check for priority of current task to be added and priority of the task inthe file
        if not added and prioritynum > add_task_prioritynum:
            tasks_list.append(task_string)
            added = True
        tasks_list.append(" ".join(task))

    if not added:
        tasks_list.append(task_string)

    task_file_handle.close()
    task_file_handle = open('task.txt', 'w')
    for task in tasks_list:
        task_file_handle.write(task+'\n')

    success_message = "Added task: \""+add_task + \
        "\" with priority "+str(add_task_prioritynum)+"\n"
    sys.stdout.buffer.write(success_message.encode('utf8'))

    task_file_handle.close()



# ./task ls
def ls():
    try:
        task_file_handle = open('task.txt', 'r')
    except:
        task_file_handle = open('task.txt', 'w+')

    tasks = task_file_handle.read().split('\n')[:-1]
    # sliced tasks to eliminate line generated by \n in the end of the file

    # i - to identify the index of the item
    i=1

    if len(tasks)<=0:
        notasks="There are no pending tasks!"
        sys.stdout.buffer.write(notasks.encode('utf8'))
        return

    for task in tasks:
        task = task.split(' ')
        prioritynum=task[0]
        task_name=" ".join(task[1:])
        task_string=str(i)+". "+task_name+" ["+prioritynum+"]\n"
        sys.stdout.buffer.write(task_string.encode('utf8'))
        i=i+1

    task_file_handle.close()



# ./task del
def delete(arguments):
    # check for validity of arguments
    invalid = False
    if arguments is None:
        invalid = True
    try:
        arguments[0] = int(arguments[0])
    except:
        invalid = True

    if invalid:
        print("Error: Missing NUMBER for deleting tasks.")
        return
    
    index=arguments[0]

    try:
        task_file_handle = open('task.txt', 'r')
    except:
        task_file_handle = open('task.txt', 'w+')

    tasks = task_file_handle.read().split('\n')[:-1]
    # sliced tasks to eliminate line generated by \n in the end of the file
    tasks_list=[]

    # deleted - to mark if the item with the given index exists, if yes deleted
    # i - to identify the index of the item
    deleted=False
    i=1

    for task in tasks:
        if i==index:
            deleted=True
            i=i+1
            continue
        tasks_list.append(task)
        i=i+1

    task_file_handle.close()
    
    if deleted:
        task_file_handle = open('task.txt', 'w')
        for task in tasks_list:
            task_file_handle.write(task+'\n')

        success_message="Deleted task #"+ str(index)
        sys.stdout.buffer.write(success_message.encode('utf8'))
    else:
        failure_message="Error: task with index #"+ str(index) +" does not exist. Nothing deleted."
        sys.stdout.buffer.write(failure_message.encode('utf8'))




# ./task done
def done(arguments):
    # check for validity of arguments
    invalid = False
    if arguments is None:
        invalid = True
    try:
        arguments[0] = int(arguments[0])
    except:
        invalid = True

    if invalid:
        print("Error: Missing NUMBER for marking tasks as done.")
        return
    
    index=arguments[0]

    try:
        task_file_handle = open('task.txt', 'r')
    except:
        task_file_handle = open('task.txt', 'w+')
        
    tasks = task_file_handle.read().split('\n')[:-1]
    # sliced tasks to eliminate line generated by \n in the end of the file
    tasks_list=[]

    # done - to mark if the item with the given index exists, if yes, mark it as done
    # i - to identify the index of the item
    done=False
    i=1

    completed_file_handle = open('completed.txt', 'a')

    for task in tasks:
        if i==index:
            done=True
            task = task.split(' ')
            task_name=" ".join(task[1:])
            completed_file_handle.write(task_name+'\n')
            i=i+1
            continue
        tasks_list.append(task)
        i=i+1
    
    task_file_handle.close()
    
    if done:
        task_file_handle = open('task.txt', 'w')
        for task in tasks_list:
            task_file_handle.write(task+'\n')

        success_message="Marked item as done."
        sys.stdout.buffer.write(success_message.encode('utf8'))
    else:
        failure_message="Error: no incomplete item with index #"+str(index)+" exists."
        sys.stdout.buffer.write(failure_message.encode('utf8'))

    task_file_handle.close()
    completed_file_handle.close()



# ./task report
def report():
    try:
        task_file_handle = open('task.txt', 'r')
    except:
        task_file_handle = open('task.txt', 'w+')

    tasks = task_file_handle.read().split('\n')[:-1]
    # sliced tasks to eliminate line generated by \n in the end of the file

    pending="Pending : "+str(len(tasks))+"\n"
    sys.stdout.buffer.write(pending.encode('utf8'))
    ls()

    try:
        completed_file_handle=open('completed.txt', 'r')
    except:
        completed_file_handle=open('completed.txt', 'w+')

    completed_tasks=completed_file_handle.read().split('\n')[:-1]
    # sliced completed_tasks to eliminate line generated by \n in the end of the file

    completed="\nCompleted : "+str(len(completed_tasks))+"\n"
    sys.stdout.buffer.write(completed.encode('utf8'))

    # i - to identify the index of the item
    i=1

    for task in completed_tasks:
        task_string=str(i)+". "+task+"\n"
        sys.stdout.buffer.write(task_string.encode('utf8'))
        i=i+1

    task_file_handle.close()
    completed_file_handle.close()
        


def main(argv):
    command = None
    arguments = None

    if argv:
        command = argv[0]
    if len(argv) > 1:
        arguments = argv[1:]

    if (command is None) or command == 'help':
        taskhelp()
    elif command == 'add':
        add(arguments)
    elif command == 'ls':
        ls()
    elif command == 'del':
        delete(arguments)
    elif command == 'done':
        done(arguments)
    elif command == 'report':
        report()
    else:
        print("Type './task help' for usage")


# to ensure that the script won't run when imported as a module
# slicing of argv so that the file name doesn't get passed to the main function
# all the arguments from the command line are passed as a string
if __name__ == '__main__':
    main(sys.argv[1:])
